"""HFSS manager that orchestrates the workflow."""
from typing import Optional, Dict, Any, List
from .pyaedt_wrapper import PyAedtSession

class HFSSManager:
    """Thin orchestrator for HFSS workflows."""

    def __init__(self, project_name: Optional[str] = None, non_graphical: bool = True, use_pyaedt: Optional[bool] = None):
        self.project_name = project_name
        self.non_graphical = non_graphical
        self.use_pyaedt = use_pyaedt
        self._session: Optional[PyAedtSession] = None

    def __enter__(self):
        self._session = PyAedtSession(
            project_name=self.project_name, 
            non_graphical=self.non_graphical, 
            use_pyaedt=self.use_pyaedt
        )
        self._session.__enter__()
        return self

    def __exit__(self, exc_type, exc, tb):
        if self._session:
            self._session.__exit__(exc_type, exc, tb)
            self._session = None

    @property
    def session(self) -> PyAedtSession:
        if not self._session:
            raise RuntimeError("HFSSManager not started; use 'with HFSSManager(...) as m:'")
        return self._session

    def apply_tasks(self, tasks: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Executes a list of tasks generated by the LLM.
        Maps 'neuro' intent (text actions) to 'symbolic' execution (pyaedt calls).
        """
        log = []
        status = "ok"
        
        # Accumulate geometry params because LLM might split them (substrate vs patch)
        geometry_params = {} 
        antenna_type = "dipole" # Default

        for t in tasks:
            try:
                tid = t.get("id")
                action = t.get("action", "").lower()
                params = t.get("params") or {}
                
                # --- 1. Geometry Phase ---
                if action in ("create_substrate", "create_patch"):
                    antenna_type = "patch"
                    # Merge params (e.g. width_mm, length_mm, dielectric_constant)
                    geometry_params.update(params)
                    log.append({"id": tid, "result": "Parameters buffered for Patch generation"})
                
                elif action == "create_dipole":
                    antenna_type = "dipole"
                    geometry_params.update(params)
                    log.append({"id": tid, "result": "Parameters buffered for Dipole generation"})

                # --- 2. Excitation/Boundary Phase ---
                # (In this simplified architecture, we build the whole antenna + ports 
                # in one go using the 'add_patch' or 'add_dipole' methods of the wrapper.
                # So we trigger the build when we see an excitation or just later.)
                elif action in ("assign_excitation", "assign_port"):
                    # Trigger the geometry build now if not done
                    if antenna_type == "patch":
                        desc = self.session.add_patch(geometry_params)
                    else:
                        desc = self.session.add_dipole(geometry_params)
                    
                    # Now assign the port
                    # Note: Our wrappers 'add_*' methods usually include ports for simplicity,
                    # but we can try calling assign_port if the wrapper supports it.
                    self.session.assign_port(desc, params)
                    log.append({"id": tid, "result": f"Geometry built & Port assigned for {antenna_type}"})

                elif action in ("assign_boundary", "assign_perfect_e"):
                    # Usually handled in add_patch, just log it
                    log.append({"id": tid, "result": "Boundary conditions applied (via geometry template)"})

                # --- 3. Analysis Phase ---
                elif action in ("create_setup", "analysis_setup"):
                    self.session.create_setup("AutoSetup", params)
                    log.append({"id": tid, "result": f"Setup created: {params}"})

                elif action in ("analyze", "solve"):
                    print("   ... Running Simulation (this may take a moment) ...")
                    self.session.analyze()
                    log.append({"id": tid, "result": "Simulation completed"})

                # --- 4. Reporting Phase ---
                elif action in ("export_report", "postprocess"):
                    # Default to S11 if not specified
                    report_name = params.get("report_type", "S11")
                    filename = params.get("file_name", "S11.csv")
                    self.session.export_report(report_name, filename)
                    log.append({"id": tid, "result": f"Exported {filename}"})

                else:
                    log.append({"id": tid, "result": f"Skipped unknown action: {action}"})

            except Exception as e:
                print(f"âŒ Error executing task {tid}: {e}")
                status = "error"
                log.append({"id": tid, "error": str(e)})

        return {"status": status, "log": log}

    def run_antenna_workflow(self, antenna, setup_name: str = "Setup1", setup_params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute standard build -> excite -> solve -> extract workflow."""
        # 1. Build Geometry
        built = antenna.build_in_hfss(self.session)

        # 2. Setup Analysis (Frequency Sweep)
        self.session.create_setup(setup_name, setup_params)

        # 3. Run Simulation (Analyze)
        solve_res = self.session.analyze()

        # 4. Results
        results = antenna.postprocess(self.session)

        return {
            "built": built,
            "solve": solve_res,
            "results": results,
            "log": getattr(self.session, "log", [])
        }

    # Backwards-compatible small helpers
    def start_session(self):
        return self.__enter__()

    def close(self):
        return self.__exit__(None, None, None)